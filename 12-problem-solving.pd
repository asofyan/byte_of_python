# Pemecahan Masalah

Setelah sebelumnya kita telah mengeksplorasi berbagai bagian bahasa Python, sekarang kita coba untuk menggabungkan bagian-bagian tadi menjadi satu kesatuan, dengan mendesain dan membuat program yang *benar-benar* berguna. Idenya adalah belajar bagaimana Anda menulis skrip Python sendiri.

## Permasalahan

Permasalahan yang ingin dipecahkan adalah *"Saya ingin membuat sebuah program yang membackup semua berkas-berkas saya yang penting."*.

Meskipun ini masalah sederhana, namun tidak ada informasi yang cukup bagi kita untuk mulai dengan pemecahannya. Hal ini membutuhkan sedikit **analisa lanjutan**. Sebagai contoh, bagaimana kita menentukan berkas *mana* yang penting sehingga perlu dibackup? *Bagaimana* berkas-berkas tersebut disimpan? *Di mana* tempat penyimpanannya?

Setelah menganalisa masalah tersebut secara lebih mendalam, kita mulai **mendesain** program kita. Kita bisa mulai dengan membuat daftar bagaimana program kita akan berjalan nantinya. Dalam kasus ini, Saya telah membuat daftar berikut tentang bagaimana *Saya* ingin program tersebut bekerja. Jika Anda melakukan sendiri desainnya, mungkin Anda akan membuat analisa berbeda mengingat setiap orang punya pendekatan berbeda tentang bagaimana cara mereka melakukan pekerjaannya. Dan ini sama sekali bukan masalah. Tidak apa-apa. 

- Berkas dan direktori akan disimpan dalam berkas pendukung (_backup_) secara khusus dalam list.
- Berkas pendukung harus disimpan dalam direktori pendukung utama.
- Semua berkas disimpan dalam berkas pendukung dengan format zip.
- Penamaan dalam berkas arsip berformat zip  dibuat dalam tanggal dan waktu sekarang.
- Kita menggunakan perintah baku `zip` yang sudah tersedia dalam setiap distribusi Linux/Unix. Pengguna Windows dapat [memasang](http://gnuwin32.sourceforge.net/downlinks/zip.php) dari [Halaman Proyek GnuWin32 ](http://gnuwin32.sourceforge.net/packages/zip.htm) and add `C:\Program Files\GnuWin32\bin` ke dalam variabel lingkungan yang dikenal oleh PATH sistem, sama seperti [cara kita mengenal perintah python sendiri](#dos-prompt). Perhatikan bahwa perintah untuk mengarsipkan berkas dapat Anda gunakan selama aplikasi tersebut tersedia dan bisa diakses melalui baris perintah. 

## Solusi 

Mengingat desain program kita relatif sudah komplit dan stabil, sekarang kita dapat menuliskan kode sebagai **implementasi** dari solusi kita. 

Simpan sebagai `backup_ver1.py`:

~~~python
import os
import time

# 1. Berkas dan direktori akan disimpan dalam berkas pendukung (_back up_) secara khusus dalam list.
source = ['"C:\\My Documents"', 'C:\\Code']
# Perhatikan bahwa kita harus menggunakan petik dua di dalam string yang memiliki spasi di dalamnya.

# 2. Berkas pendukung harus disimpan dalam direktori pendukung utama.
target_dir = 'E:\\Backup' # Ingat bahwa ini harus diganti dengan direktori yang benar-benar Anda gunakan

# 3. Semua berkas disimpan dalam berkas pendukung dengan format zip.
# 4. Penamaan dalam berkas arsip berformat zip  dibuat dalam tanggal dan waktu sekarang.
target = target_dir + os.sep + time.strftime('%Y%m%d%H%M%S') + '.zip'

# 5. Kita gunakan perintah zip untuk memasukkan berkas ke dalam arsip zip
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# Jalankan backup
if os.system(zip_command) == 0:
    print('Backup berhasil dilakukan ke', target)
else:
    print('Backup GAGAL')
~~~

Keluaran:

~~~
$ python backup_ver1.py
Backup berhasil dilakukan ke E:\Backup\20080702185040.zip
~~~

Sekarang, kita dalam fase **testing** untuk menguji apakah program yang kita buat dapat berjalan dengan baik. Jika tidak berjalan sesuai harapan, kita harus melakukan **debug** terhadap program kita, yakni dengan memperbaiki *bus* (kesalahan) dari program. 

Jika kode program di atas tidak berjalan, buat satu baris perintah `print(zip_command)` di atas baris `os.system', dan jalankan program kembali. Kemudian, salin/tempel hasil keluaran print zip_command yang ada di layar, dan lihat apakah tulisan yang tampil sudah menunjukkan bahwa program sudah berjalan dengan benar. Jika perintah tersebut gagal, cek kembali petunjuk perintah zip dan cari kemungkinan-kemungkinan kekeliruan. Jika perintah ini berhasil dijalankan, lihat kembali program Python Anda apakah keluarannya sesuai dengan apa yang tertulis di atas. 

Bagaimana Cara Kerjanya:

Anda akan memahami bahwa kita telah mengonversi *desain* menjadi *kode program* langkah demi langkah. 

Kita menggunakan modul `os` dan `time` dengan cara mengimpornya terlebih dahulu. Kemudian, kita tentukan berkas dan direktori yang akan dibackup ke dalam direktori yang kita namakan lewat variabel `target_dir`. Nama file arsip zip yang akan kita buat, terdiri dari tanggal dan waktu saat perintah tersebut dijalankan dengan menggunakan fungsi `time.strftime()`. Pembuatan berkas tersebut juga akan menambahkan ekstensi `.zip` dan akan disimpan pada direktori `target_dir`. 

Perhatikan bahwa variabel `os.sep` - yang akan memberikan pemisah antar direktori yang sesuai dengan sistem operasi Anda, yakni `'/'` jika berada dalam lingkungan Linux dan Unix, atau `'\\'` di Windows dan `':'` di Mac OS. Penggunaan fungsi `os.sep` daripada menuliskan langsung karakter pemisahnya akan membuat program kita portabel dan berjalan di sistem yang heterogen. 

Fungsi `time.strftime()` akan mengambil karakter tertentu yang sudah ditentukan untuk kita gunakan di program di atas. Karakter spesifik `%Y` akan diganti dengan tahun. Sedangkan `%m` akan diganti nama bulan dengan format desimal antara `01` hingga `12` dan seterusnya. Spesifikasi lengkap terhadap hal ini bisa dilihat di [Manual Referensi Python](http://docs.python.org/py3k/library/time.html#time.strftime).

Kita membuat nama dari file arsip yang dituju dengan tambahan operator yang *menggabungkan/concatenates* string, yakni dengan menggabungkan dua string untuk menjadi satu string gabungan. Kemudian kita juga membuat string `zip_command` yang berisi seluruh perintah yang akan kita eksekusi. Anda dapat mengecek apakah perintah ini berjalan atau tidak dengan menjalankannya di shell (baik di terminal Linux atau prompt DOS).

Perintah `zip` yang kita gunakan memiliki opsi dan parameter yang bisa dimasukkan. Opsi `-q` digunakan sebagai indikasi bahwa perintah zip haraus berjalan secara diam-diam (**q**uietly). Opsi `-r` menunjukkan bahwa perintah zip harus dijalankan secara **r**ekursif di dalam direktori, yakni dengan memasukkan seluruh sub direktori dan berkas di bawahnya. Kedua parameter tersebut dapat digabung menjadi satu parameter `-qr`. Opsi tersebut diikuti nama berkas arsip zip yang didalamnya akan diisi arsip seluruh berkas dan direktori yang akan dibackup. Kita mengonversi list `source` menjadi string lewat metode yang sudah pernah kita lihat penggunaannya sebelumnya, yakni `join` string. 

Lalu kita benar-benar *menjalankan* perintah tersebut lewat fungsi `os.system` di mana fungsi tersebut akan menjalankan perintah seolah-olah dijalankan oleh *sistem*, yakni akan memberikan kembalian `0` jika berhasil, dan jika gagal akan memberikan nomor pesan kesalahan yang sesuai dengan sistem operasinya. 

Tergantung dari keluaran perintah di atas, kita akan mencetak pesan pelaksanaan backup tersebut apakah gagal atau berhasil.

Itu saja, kita telah membuat skrip untuk membackup seluruh berkas-berkas penting kita!

Catatan untuk pengguna Windows

:   Selain menggunakan backslash (garis miring kiri) untuk lepas dari urutan (_sequences_), Anda bisa menggunakan string dasar. Sebagai contoh `'C:\\Documents'` atau `r'C:\Documents'`. Meskipun demikian **jangan** menggunakan `'C:\Documents'` karena nantinya akan dianggap sebagai string urutan lepas (_escape sequence_) `\D`. 

Sekarang kita sudah memiliki skrip backup yang berjalan dengan baik, dan kita bisa menggunakannya setiap saat kita butuhkan untuk membuat backup berkas. Pengguna Linux/Unix sangat disarankan untuk menggunakan [metode yang bisa dieksekusi](#executable-python-programs) sebagaimana yang telah kita diskusikan sebelumnya, sehingga kita dapat menjalankan skrip backup kapan saja dan di mana saja. Hal ini sering disebut fase **operasi** atau fase **deployment** dari sebuah perangkat lunak.

Meskipun program di atas dapat berjalan sebagaimana mestinya, tapi (biasanya) program pertama kali dijalankan tidak sesuai dengan yang diinginkan. Sebagai conth, mungkin akan ada masalah jika Anda tidak mendesain program dengan layak, atau Anda melakukan kesalahan saat mengetikkan kode sintaks, dan sebagainya. Selayaknya, kita harus kembali ke fase desain atau nanti Anda harus debug program yang Anda buat. 

## Versi Kedua

Versi pertama dari program yang kita buat telah berjalan sebagaimana mestinya. Meskipun demikian, kita bisa saja membuat beberapa perbaikan sehingga dapat berjalan lebih baik setiap harinya. Ini disebut sebagai fase **pemeliharaan** dari pengembangan perangkat lunak. 

Salah satu perbaikan yang saya pikir akan berguna lebih baik adalah mekanisme penamaan berkas - dengan menggunakan *waktu* sebagai bagian dari nama berkas di dalam direktori backup utama. Keuntungan pertama adalah, backup Anda akan disimpan dalam format yang hierarkis sehingga lebih mudah untuk diatur. Keuntungan kedua, nama berkas jauh lebh pendek. Keuntungan ketiga, direktori yang terpisah akan membantu Anda jika Anda mambuat backup tiap hari, dan direktori yang terbuat adalah direktori yang memang benar-benar dibuat di hari itu. 

Simpan sebagai `backup_ver2.py`:

~~~python
import os
import time

# 1. Berkas dan direktori yang dibackup disebut secara khusus dalam daftar(_list_).
sumber = ['"C:\\My Documents"', 'C:\\Code']
# Perhatikan bahwa kita menggunakan tanda petik dua di dalam string untuk nama yang memiliki spasi.

# 2. Backup harus disimpan di dalam direktori backup utama
target_dir = 'E:\\Backup' # Remember to change this to what you will be using

# 3. The files are backed up into a zip file.
# 4. The current day is the name of the subdirectory in the main directory
today = target_dir + os.sep + time.strftime('%Y%m%d')
# The current time is the name of the zip archive
now = time.strftime('%H%M%S')

# Create the subdirectory if it isn't already there
if not os.path.exists(today):
    os.mkdir(today) # make directory
    print('Successfully created directory', today)

# The name of the zip file
target = today + os.sep + now + '.zip'

# 5. We use the zip command to put the files in a zip archive
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# Run the backup
if os.system(zip_command) == 0:
    print('Successful backup to', target)
else:
    print('Backup FAILED')
~~~

Output:

~~~
$ python3 backup_ver2.py
Successfully created directory E:\Backup\20080702
Successful backup to E:\Backup\20080702\202311.zip

$ python3 backup_ver2.py
Successful backup to E:\Backup\20080702\202325.zip
~~~

How It Works:

Most of the program remains the same. The changes are that we check if there is a directory with the current day as its name inside the main backup directory using the `os.path.exists` function. If it doesn't exist, we create it using the `os.mkdir` function.

## Third Version

The second version works fine when I do many backups, but when there are lots of backups, I am finding it hard to differentiate what the backups were for! For example, I might have made some major changes to a program or presentation, then I want to associate what those changes are with the name of the zip archive. This can be easily achieved by attaching a user-supplied comment to the name of the zip archive.

Note

:   The following program does not work, so do not be alarmed, please follow along because there's a lesson in here.

Save as `backup_ver3.py`:

~~~python
import os
import time

# 1. The files and directories to be backed up are specified in a list.
source = ['"C:\\My Documents"', 'C:\\Code']
# Notice we had to use double quotes inside the string for names with spaces in it.

# 2. The backup must be stored in a main backup directory
target_dir = 'E:\\Backup' # Remember to change this to what you will be using

# 3. The files are backed up into a zip file.
# 4. The current day is the name of the subdirectory in the main directory
today = target_dir + os.sep + time.strftime('%Y%m%d')
# The current time is the name of the zip archive
now = time.strftime('%H%M%S')

# Take a comment from the user to create the name of the zip file
comment = input('Enter a comment --> ')
if len(comment) == 0: # check if a comment was entered
    target = today + os.sep + now + '.zip'
else:
    target = today + os.sep + now + '_' +
        comment.replace(' ', '_') + '.zip'

# Create the subdirectory if it isn't already there
if not os.path.exists(today):
    os.mkdir(today) # make directory
    print('Successfully created directory', today)

# 5. We use the zip command to put the files in a zip archive
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# Run the backup
if os.system(zip_command) == 0:
    print('Successful backup to', target)
else:
    print('Backup FAILED')
~~~

Output:

~~~
$ python3 backup_ver3.py
  File "backup_ver3.py", line 25
    target = today + os.sep + now + '_' +
                                        ^
SyntaxError: invalid syntax
~~~

How This (does not) Work:

**This program does not work!** Python says there is a syntax error which means that the script does not satisfy the structure that Python expects to see. When we observe the error given by Python, it also tells us the place where it detected the error as well. So we start *debugging* our program from that line.

On careful observation, we see that the single logical line has been split into two physical lines but we have not specified that these two physical lines belong together. Basically, Python has found the addition operator (`+`) without any operand in that logical line and hence it doesn't know how to continue. Remember that we can specify that the logical line continues in the next physical line by the use of a backslash at the end of the physical line. So, we make this correction to our program. This correction of the program when we find errors is called **bug fixing**.

## Fourth Version

Save as `backup_ver4.py`:

~~~python
import os
import time

# 1. The files and directories to be backed up are specified in a list.
source = ['"C:\\My Documents"', 'C:\\Code']
# Notice we had to use double quotes inside the string for names with spaces in it.

# 2. The backup must be stored in a main backup directory
target_dir = 'E:\\Backup' # Remember to change this to what you will be using

# 3. The files are backed up into a zip file.
# 4. The current day is the name of the subdirectory in the main directory
today = target_dir + os.sep + time.strftime('%Y%m%d')
# The current time is the name of the zip archive
now = time.strftime('%H%M%S')

# Take a comment from the user to create the name of the zip file
comment = input('Enter a comment --> ')
if len(comment) == 0: # check if a comment was entered
    target = today + os.sep + now + '.zip'
else:
    target = today + os.sep + now + '_' + \
        comment.replace(' ', '_') + '.zip'

# Create the subdirectory if it isn't already there
if not os.path.exists(today):
    os.mkdir(today) # make directory
    print('Successfully created directory', today)

# 5. We use the zip command to put the files in a zip archive
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# Run the backup
if os.system(zip_command) == 0:
    print('Successful backup to', target)
else:
    print('Backup FAILED')
~~~

Output:

~~~
$ python3 backup_ver4.py
Enter a comment --> added new examples
Successful backup to E:\Backup\20080702\202836_added_new_examples.zip

$ python3 backup_ver4.py
Enter a comment -->
Successful backup to E:\Backup\20080702\202839.zip
~~~

How It Works:

This program now works! Let us go through the actual enhancements that we had made in version 3. We take in the user's comments using the `input` function and then check if the user actually entered something by finding out the length of the input using the `len` function. If the user has just pressed `enter` without entering anything (maybe it was just a routine backup or no special changes were made), then we proceed as we have done before.

However, if a comment was supplied, then this is attached to the name of the zip archive just before the `.zip` extension.  Notice that we are replacing spaces in the comment with underscores - this is because managing filenames without spaces is much easier.

## More Refinements

The fourth version is a satisfactorily working script for most users, but there is always room for improvement. For example, you can include a *verbosity* level for the program where you can specify a `-v` option to make your program become more talkative.

Another possible enhancement would be to allow extra files and directories to be passed to the script at the command line. We can get these names from the `sys.argv` list and we can add them to our `source` list using the `extend`method provided by the `list` class.

The most important refinement would be to not use the `os.system` way of creating archives and instead using the `zipfile` or `tarfile` built-in module to create these archives. They are part of the standard library and available already for you to use without external dependencies on the zip program to be available on your computer.

However, I have been using the `os.system` way of creating a backup in the above examples purely for pedagogical purposes, so that the example is simple enough to be understood by everybody but real enough to be useful.

Can you try writing the fifth version that uses the [zipfile](http://docs.python.org/py3k/library/zipfile.html) module instead of the `os.system` call?

## The Software Development Process

We have now gone through the various **phases** in the process of writing a software. These phases can be summarised as follows:

#. What (Analysis)
#. How (Design)
#. Do It (Implementation)
#. Test (Testing and Debugging)
#. Use (Operation or Deployment)
#. Maintain (Refinement)

A recommended way of writing programs is the procedure we have followed in creating the backup script: Do the analysis and design. Start implementing with a simple version. Test and debug it. Use it to ensure that it works as expected. Now, add any features that you want and continue to repeat the Do It-Test-Use cycle as many times as required. Remember, **Software is grown, not built**.

## Summary

We have seen how to create our own Python programs/scripts and the various stages involved in writing such programs. You may find it useful to create your own program just like we did in this chapter so that you become comfortable with Python as well as problem-solving.

Next, we will discuss object-oriented programming.
