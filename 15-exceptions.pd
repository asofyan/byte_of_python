# Eksepsi 

Eksepsi (pengecualian) akan muncul jika terjadi sesuatu di program Anda yang bersifat *pengecualian*. Misalnya, bagaimana jika Anda ingin membuka satu berkas dan berkas tersebut tidak ada? Atau bagaimana jika Anda secara tidak sengaja menghapusnya saat program masih berjalan? Kondisi semacam ini ditangani dengan menggunakan **eksepsi**.

Mirip dengan itu, bagaimana jika program Anda memiliki statemen yang tidak valid? Hal ini ditangani oleh Python dengan **mengangkat** tangannya dan menyampaikan kepada Anda telah terjadi **kesalahan/_error_** Similarly, what if your program had some invalid statements? This is handled by Python which **raises** its hands and tells you there is an **error**.

## Error 

Misalnya Anda ingin memanggil fungsi sederhana `print`. Bagaimana jika kita salah tulis dari `print` menjadi `Print`? Perhatikan huruf besar di awalnya. Dalam hal ini, Python akan *mengangkat* error sintaksis. 

~~~
>>> Print('Halo Dunia')
Traceback (most recent call last):
  File "<pyshell#0>", line 1, in <module>
    Print('Halo Dunia')
NameError: name 'Print' is not defined
>>> print('Halo Dunia')
Halo Dunia
~~~

Jika Anda perhatikan `NameError` muncul bersama dengan lokasi dimana error terdeteksi. Ini yang disebut sebagai *penanganan kesalahan/_error handler_*. 

## Eksepsi 

Kita akan **mencoba** membaca masukan dari pnegguna. Tekan `ctrl-d` dan lihat apa yang terjadi.

~~~
>>> s = input('Masukkan Sesuatu --> ')
Masukkan Sesuatu --> 
Traceback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
    s = input('Masukkan Sesuatu --> ')
EOFError: EOF when reading a line
~~~

Python memunculkan kesalahan yang dinamakan `EOFError`, pada dasarnya dia menemukan sebuah simbol *end of file/akhir berkas* (yang diwakilkan dalam bentuk `ctrl-d`) saat Python tidak mengharapkan kemunculannya.

## Menangani Eksepsi 

Kita dapat menangani ekspsi dengan menggunakan statemen `try..except`. Pada dasarnya kita meletakkan statemen seperti biasa ke dalam blok `try` dan meletakkan seluruh penanganan kesalahan ke dalam blok `except`. 

Contoh (simpan sebagai `try_except.py`):

~~~python
try:
    text = input('Masukkan sesuatu --> ')
except EOFError:
    print('Kenapa Anda melakukan EOF terhadap saya?')
except KeyboardInterrupt:
    print('Anda membatalkan operasi.')
else:
    print('Anda memasukkan {0}'.format(text))
~~~

Keluaran:

~~~
$ python3 try_except.py
Masukkan sesuatu -->     # Press ctrl-d
Kenapa Anda melakukan EOF terhadap saya?

$ python3 try_except.py
Masukkan sesuatu -->     # Press ctrl-c
Anda membatalkan operasi.

$ python3 try_except.py
Masukkan sesuatu --> tidak ada pengecualian 
Anda memasukkan tidak ada pengecualian
~~~

Bagaimana Cara Kerjanya:

Kita menempatkan semua statemen yang akan memunculkan eksepsi atau pesan kesalahan di dalam blok `try` kemudian meletakkan penanggung jawab (_handler_) ke dalam blok `except`. Klausa `except` ini dapat menangani eksepsi atau pesan kesalahan tunggal, atau penanganan lebih dari satu eksepsi yang ditulis dengan pemisah koma. Jika pesan kesalahan atau eksepsinya tidak ditulis, dia akan menangani *semua* eksepsi dan pesan kesalahan. 

Mohon dicatat bahwa harus ada paling tidak satu klausa `except` pada setiap klausa `try` yang dibuat. Jika tidak, untuk apa membuat blok `try`? 

Jika pesan kesalahan atau eksepsi tidak ditangani, maka handler Python yang baku akan dipanggil, program akan berhenti dan menampilkan pesan kesalahan. Kita sudah lihat hal ini sebelumnya.

Anda juga dapat menggunakan klausa `else` pada setiap blok `try..except`. Klausa ini akan dieksekusi jika tidak ada eksepsi yang terjadi. 

Dalam contoh berikutnya, kita juga akan melihat bagaimana cara memperoleh eksepsi dari sebuah obyek sehingga kita bisa mengambil informasi lebih banyak.

## Memunculkan Eksepsi

Anda dapat *memunculkan* eksepsi dengan menggunakan statemen `raise` dengan memberikan nama dari kesalahan/ekspsi dan obyek eksepsi yang akan *dilemparkan*

Kesalahan atau eksepsi yang dapat Anda munculkan harus berupa kelas yang secara langsung atau tidak diturunkan dari kelas `Exception`. 

Contoh (simpan dengan nama `raising.py`):

~~~python
class ShortInputException(Exception):
    '''A user-defined exception class.'''
    def __init__(self, length, atleast):
        Exception.__init__(self)
        self.length = length
        self.atleast = atleast

try:
    text = input('Enter something --> ')
    if len(text) < 3:
        raise ShortInputException(len(text), 3)
    # Other work can continue as usual here
except EOFError:
    print('Why did you do an EOF on me?')
except ShortInputException as ex:
    print('ShortInputException: The input was {0} long, expected at least {1}'\
          .format(ex.length, ex.atleast))
else:
    print('No exception was raised.')
~~~

Output:

~~~
$ python3 raising.py
Enter something --> a
ShortInputException: The input was 1 long, expected at least 3

$ python3 raising.py
Enter something --> abc
No exception was raised.
~~~

How It Works:

Here, we are creating our own exception type. This new exception type is called `ShortInputException`. It has two fields - `length` which is the length of the given input, and `atleast` which is the minimum length that the program was expecting.

In the `except` clause, we mention the class of error which will be stored `as` the variable name to hold the corresponding error/exception object. This is analogous to parameters and arguments in a function call. Within this particular `except` clause, we use the`length` and `atleast` fields of the exception object to print an appropriate message to the user.

## Try .. Finally 

Suppose you are reading a file in your program. How do you ensure that the file object is closed properly whether or not an exception was raised? This can be done using the `finally` block. Note that you can use an `except` clause along with a `finally` block for the same corresponding `try` block. You will have to embed one within another if you want to use both.

Save as `finally.py`:

~~~python
import time

try:
    f = open('poem.txt')
    while True: # our usual file-reading idiom
        line = f.readline()
        if len(line) == 0:
            break
        print(line, end='')
        time.sleep(2) # To make sure it runs for a while
except KeyboardInterrupt:
    print('!! You cancelled the reading from the file.')
finally:
    f.close()
    print('(Cleaning up: Closed the file)')
~~~

Output:

~~~
$ python3 finally.py
Programming is fun
When the work is done
if you wanna make your work also fun:
!! You cancelled the reading from the file.
(Cleaning up: Closed the file)
~~~

How It Works:

We do the usual file-reading stuff, but we have arbitrarily introduced sleeping for 2 seconds after printing each line using the `time.sleep` function so that the program runs slowly (Python is very fast by nature). When the program is still running, press `ctrl-c` to interrupt/cancel the program.

Observe that the `KeyboardInterrupt` exception is thrown and the program quits. However, before the program exits, the finally clause is executed and the file object is always closed.

## The with statement 

Acquiring a resource in the `try` block and subsequently releasing the resource in the `finally` block is a common pattern. Hence, there is also a `with` statement that enables this to be done in a clean manner:

Save as `using_with.py`:

~~~python
with open("poem.txt") as f:
    for line in f:
        print(line, end='')
~~~

How It Works:

The output should be same as the previous example. The difference here is that we are using the `open` function with the `with` statement - we leave the closing of the file to be done automatically by `with open`.

What happens behind the scenes is that there is a protocol used by the `with` statement. It fetches the object returned by the `open` statement, let's call it "thefile" in this case.

It *always* calls the `thefile.__enter__` function before starting the block of code under it and *always* calls `thefile.__exit__` after finishing the block of code.

So the code that we would have written in a `finally` block should be taken care of automatically by the `__exit__`method. This is what helps us to avoid having to use explicit `try..finally` statements repeatedly.

More discussion on this topic is beyond scope of this book, so please refer [PEP 343](http://www.python.org/dev/peps/pep-0343/) for a comprehensive explanation.

## Summary 

We have discussed the usage of the `try..except` and `try..finally` statements. We have seen how to create our own exception types and how to raise exceptions as well.

Next, we will explore the Python Standard Library.
