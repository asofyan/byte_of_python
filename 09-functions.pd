# Fungsi

Fungsi merupakan bagian yang dapat digunakan kembali di dalam program. Fungsi tersebut memungkinkan Anda memberi nama terhadap blok statemen, yang memungkinkan Anda menjalankan blok tersebut di program Anda kapan saja berkali-kali dengan memanggil namanya.  Ini dinamakan *pemanggilan* terhadap fungsi. Kita sudah pernah menggunakan beberapa fungsi yang sudah built-in seperti `len` dan `range`.

Konsep tentang fungsi ini mungkin merupakan *struktur pembangun* yang paling penting perangkat lunak (dalam bahasa pemrograman apapun), dan kita akan mengeksplorasi bermacam aspek dari fungsi dalam bab ini.

Fungsi ditentukan dengan menggunakan kata kunci `def`. Setelah kata kunci, diikuti dengan nama *penanda* dari fungsi tersebut, diikut pasangan dalam kurung yang di dalamnya ada nama variabel. Setelah tanda kurung, akan ditutup dengan titik dua di akhir baris. Kemudian di baris baru akan diikuti blok statemen yang merupakan bagian dari fungsi tersebut. Contoh yang menunjukkan betapa sederhananya sebuah fungsi:

Contoh (simpan dengan nama `function1.py`):

~~~python
def apaKabar():
    print('Apa kabar dunia!') # blok ini milik fungsi sayHello()
# Akhir fungsi

apaKabar() # memanggil fungsi
apaKabar() # memanggil kembali fungsi
~~~

Keluaran:

~~~
$ python3 function1.py
Apa kabar dunia!
Apa kabar dunia!
~~~

Bagaimana Cara Kerjanya:

Kita mendefinisikan fungsi yang bernama `apaKabar` dengan menggunakan sintaks sebagaimana yang telah dijelaskan di atas. Fungsi ini tidak mengambil satu parameterpun, sehingga tidak perlu ada variabel yang dideklarasikan di dalam kurung. Parameter ke dalam fungsi hanyalah merupakan masukan yang digunakan di dalam fungsi, sehingga kita dapat memasukkan nilai yang berbeda untuk memperoleh hasil yang diinginkan.

Perhatikan bahwa kita dapat memanggil fungsi dua kali, yang artinya kita tidak perlu menuliskan kode yang sama lagi untuk menginginkan keluaran sama. 

## Parameter Fungsi

Fungsi dapat menerima parameter. Parameter adalah nilai yang Anda masukkan ke dalam fungsi, sehingga fungsi dapat *melakukan* sesuatu terhadap nilai tersebut. Parameter ini seperti variabel, namun Anda harus mendefinisikan nilainya dulu sebelum dimasukkan ke dalam fungsi, dan sudah memiliki nilai ketika fungsi tersebut dijalankan. 

Parameter ditentukan di dalam tanda kurung saat fungsi didefinisikan, dipisahkan dengan koma. Saat kita memanggil fungsinya, kita memasukkan nilai terhadap parameter tersebut dengan jumlah dan cara yang sama. Sebagai catatan terhadap terminologi yang digunakan - nama yang diberikan ke dalam definisi fungsi dinamakan *parameter* sedangkan nilai yang diberikan dalam pemanggilan fungsi disebut *argumen*.

Contoh (simpan dengan nama `func_param.py`):

~~~python
def printMax(a, b):
    if a > b:
        print(a, 'adalah nilai maksimum')
    elif a == b:
        print(a, 'adalah sama dengan', b)
    else:
        print(b, 'adalah nilai maksimum')

printMax(3, 4) # langsung diberikan nilai terhadap parameter a dan b saat fungsi dipanggil

x = 5
y = 7

printMax(x, y) # memberi variabel sebagai argumen. Variabel ini harus didefinisikan dulu sebelumnya.
~~~

Keluaran:

~~~
$ python3 func_param.py
4 adalah nilai maksimum
7 adalah nilai maksimum
~~~

Bagaimana Cara Kerjanya:

Di sini, kita mendefinisikan fungsi dengan nama `printMax` yang menggunakan dua parameter yang disebut `a` dan `b`. Kita mencari angka yang lebih besar dengan menggunakan statemen `if..else` sederhana, lalu mencetak angka yang lebih besar. 

Saat pertama kali kita panggil fungsi `printMax`, kita secara langsung memasukkan angka sebagai argumen. Dalam kasus kedua, kita memanggil fungsi dengan argumen berupa variabel. `printMax(x,y)` membuat nilai yang argumen `x` dimasukkan dalam parameter `a` dan nilai dari argumen `y` dimasukkan dalam parameter `b`. Fungsi `printMax` berfungsi sama saja di kedua kasus tersebut.

## Variabel Lokal

Saat Anda mendeklarasikan variabel di dalam definisi fungsi, mereka tidak berhubungan dengan variabel lain dengan nama yang sama di luar fungsi - dengan kata lain nama variabel ini hanya berlaku secara lokal di dalam fungsi. Ini dinamakan *skup* (scope) dari variabel. Semua variabel memiliki blok skup saat dideklarasikan pertama kali.

Contoh (simpan dengan nama `func_local.py`):

~~~python
x = 50

def func(x):
    print('x adalah', x)
    x = 2
    print('Mengganti nilai lokal x ke ', x)

func(x)
print('x masih tetap', x)
~~~

Keluaran:

~~~
$ python3 func_local.py
x adalah 50
Mengganti nilai lokal x ke 2
x masih tetap 50
~~~

Bagaimana Cara Kerjanya:

Saat pertama kita mencetak *nilai* dari *x* di baris pertama badan fungsi, Python menggunakan nilai dari parameter yang dideklarasikan di blok utama, di atas definisi fungsi. 

Lalu, kita memberikan nilai `2` kepada `x`. Jadi nama `x` hanya bernilai di lokal, di dalam fungsi. Saat kita mengganti nilai `x` yang berada di dalam fungsi, nilai `x` yang berada di blok utama tetap tidak terpengaruh. 

Dengan pemanggilan fungsi `print` di baris terakhir, kita menampilkan nilai `x` yang berasal dari blok utama, sehingga hal ini dapat mengonfirmasi bahwa nilai tersebut benar-benar tidak terpengaruh oleh nilai lokal yang diganti dalam fungsi sebelumnya. 

## Menggunakan Statemen Global

Jika Anda ingin memberi nilai terhadap satu variabel yang didefinisikan di level tertinggi dalam satu program (atau dengan kata lain tidak berada di dalam skup apapun, baik fungsi maupun `class`), Anda harus memberitahu Python bahwa nama tersebut bukan local, tapi *global~. Kita melakukannya dengan statemen `global`. Tidak mungkin membrikan nilai di dalam variabel di luar fungsi tanpa statemen `global`.

Anda dapat menggunakan nilai dari variabel yang didefinisikan di luar fungsi (asumsikan bahwa tidak ada nama variabel yang sama di dalam fungsi). Bagaimanapun juga, ini sangat tidak disarankan dan Anda harus menghindarinya mengingat hal tersebut akan membingungkan pembaca program tentang di mana definisi variabelnya. Menggunakan statemen `global` membuatna jelas bahwa variable yang bersangkutan didefinisikan di luar blok. 

Contoh (simpan dengan nama `func_global.py`):

~~~python
x = 50

def func():
    global x

    print('x adalah ', x)
    x = 2
    print('Mengganti nilai global x ke', x)

func()
print('Nilai dari x adalah ', x)
~~~

Keluaran:

~~~
$ python3 func_global.py
x adalah 50
Mengganti nilai global x ke 2
Nilai dari x adalah 2
~~~

Bagaimana Cara Kerjanya:

Statemen `global` digunakan untuk mendeklarasikan `x` - membuatnya menjadi variabel global - sehingga, saat kita mengganti nilai `x` di dalam fungsi, perubahan tersebut akan berlaku juga pada saat kita menggunakan nilai `x` di blok utama. 

Anda dapat menentukan lebih dari satu variabel global, dengan menggunakan statemen `global` yang sama, misalnya `global x, y, z`.

## Nilai Argumen Baku 

Untuk beberapa fungsi, Anda mungkin ingin membuat beberapa parameter *tidak wajib* diisi, dan menggunakan nilai baku pada saat pengguna tidak ingin memberikan nilai terhadapnya. Ini dapat dilakukan dengan bantuan nilai argumen baku. Anda dapat menentukan nilai arguman baku untuk parameter yang diberikan, dengan menambahkan nilai baku lewat operator sama dengan (`=`).

Catat bahwa nilai arguman baku haruslah berupa konstanta. Lebih tepatnya, nilai argumen baku harus bersifat immutable - ini akan dijelaskan di bab berikutnya. Untuk sekarang Anda hanya perlu mengingatnya.

Contoh (simpan dengan nama `func_default.py`):

~~~python
def katakan(pesan, kali = 1):
    print(pesan * kali)

katakan('Apakabar')
katakan('Dunia', 5)
~~~

Keluaran:

~~~
$ python3 func_default.py
Apakabar
DuniaDuniaDuniaDuniaDunia
~~~

Bagaimana Cara Kerjanya:

Fungsi yang bernama `katakan` digunakan untuk menampilkan string sebanyak yang ditentukan. Jika pengalinya tidak ditentukan, maka secara baku, string akan ditampilkan sebanyak sekali. Kita dapat melakukan ini dengan menentukan nilai argumen baku ke `1` untuk parameter `kali`.

Jika dalam penggunaan `katakan` pertama, kita hanya mengisi string dan mennampilkannya sekali, maka dalam penggunaan `katakan` kedua, kita mengisikan string dan sebuah arguman `5` yang menyatakan bahwa kita ingin *mengatakan* string tersebut sebanyak 5 kali.

Penting

:   Hanya parameter yang berada di akhir daftar parameter yang dapat diberikan nilai argumen baku, dengan kata lain Anda tidak boleh menentukan nilai argumen baku di depan parameter yang tidak memiliki nilai argumen baku.

    Ini karana nilai disematkan ke dalam parameter berdasarkan posisi. Sebagai contoh, `def fun(a, b=5)` dianggap valid, sedangkan `def func(a=5, b)` *tidak valid*.

## Argumen Keyword 

Jika Anda memiliki fungsi dengan banyak parameter dan Anda hanya ingin menentukan beberapa saja, Anda dapat memberikan nilai terhadap parameter, dengan memberikan nama terhadapnya - ini disebut sebagai *argumen keyword* - kita gunakan kata (keyword) daripada posisi(yang selalu kita gunakan selama ini) untuk menentukan argumen terhadap fungsi.

Ada dua *keuntungan* - satu, menggunakan fungsi akan leibh mudah sebab kita tidak perlu khawatir terhadap urutan argumen. Kedua, kita dapat memberikan nilai hanya terhadap parameter yang kita inginkan, sebab parameter lain telah memiliki nilai baku.

Contoh (simpan dengan nama `func_key.py`):

~~~python
def func(a, b=5, c=10):
    print('a adalah ', a, ' dan b adalah ', b, ' dan c adalah ', c)

func(3, 7)
func(25, c=24)
func(c=50, a=100)
~~~

Keluaran:

~~~
$ python3 func_key.py
a adalah 3 dan b adalah 7 dan c adalah 10
a adalah 325 dan b adalah 5 dan c adalah 24
a  adalah 100 dan b adalah 5 dan c adalah 50
~~~

Bagaimana Cara Kerjanya:

Fungsi tersebut bernama `func` dan hanya punya satu parameter tanpa nilai argumen baku, diikuti oleh dua parameter dengan nilai argumen baku.

Pada penggunaan pertama, `func(3, 7)`, parameter `a` memperoleh nilai `3`, parameter `b` memeperoleh nilai `7` dan `c` memperoleh nilai baku `10`.

Pada penggunaan kedua, `func(25, c=24)`, parameter `a` memperoleh nilai 25 mengingat posisinya di dalam argumen. Kemudian parameter `c` memperoleh nilai `24` berkaitan dengan penamaan argumen keyword. Variabel `b` akan memperoleh nilai baku `5`.

Dalam penggunaan ketiga `func(c=50, a=100)`, kita menggunakan argumen untuk seluruh nilai yang ditentukan. Perhatikan bahwa kita menentukan nilai untuk parameter `c` sebelum `a` didefinisikan.

## Parameter VarArgs

Kadang Anda ingin mendefinisikan fungsi yang dapat mengambil parameter dalam jumlah *berapapun*, ini dapat dilakukan dengan menggunakan tanda bintang (simpan dengan nama `total.py`): 

~~~python
def total(awal=5, *angkas, **kuncis):
    hitung = awal
    for angka in angkas:
        hitung += angka
    for kunci in kuncis:
        hitung += kuncis[kunci]
    return hitung

print(total(10, 1, 2, 3, sayur=50, buah=100))
~~~

Keluaran:

~~~
$ python3 total.py
166
~~~

Bagaimana Cara Kerjanya:

Ketika kita mendefinisikan parameter bintang seperti `*param`, maka seluruh argumen setelahnya akan dikumpulkan ke dalam tuple yang disebut `param`.

Mirip dengan itu, ketika kita mendeklarasikan parameter dua-bintang seperti `**param`, maka semua argumen dengan kata kunci akan dikumpulkan ke dalam dictionary yang disebut `param`.

Kita akan eksplorasi tentang tuples dan dictionaries di [bab berikutnya](#data-structures).

## Parameter Keyword-Only

Jika kita ingin menentukan parameter keyword tertentu yang tersedia dalam bentuk keyword-only (hanya-keyword) dan *bukan* argumen yang bersifat posisional, hal tersebut dapat dideklarasikan setelah parameter berbintang (simpan dengan nama `keyword_only.py`):

~~~python
def total(awal=5, *angkas, angka_tambahan):
    hitung = awal
    for angka in angkas:
        hitung += angka
    hitung += angka_tambahan
    print(hitung)

total(10, 1, 2, 3, angka_tambahan=50)
total(10, 1, 2, 3)
# Akan menampilkan pesan error, karena kita tidak memberikan argumen baku untuk nilai `angka_tambahan`
~~~

Keluaran:

~~~
$ python3 keyword_only.py
66
Traceback (most recent call last):
  File "keyword_only.py", line 12, in <module>
total(10, 1, 2, 3)
TypeError: total() needs keyword-only argument extra_number
~~~

Bagaimana Cara Kerjanya:

Mendeklarasikan parameter setelah parameter bintang akan menghasilkan agrumen keyword-only (hanya berupa keyword). Jika argumen ini tidak diberi nilai, maka pemanggilan fungsi akan menghasilkan pesan error sebagaimana terlihat di atas. 

Catat bahwa penggunaan `+=` merupakan jalan pintas. Jadi untuk mengatakan `x = x + y`, Anda dapat menuliskan `x += y`.

If you want to have keyword-only arguments but have no need for a starred parameter, then simply use an empty star without using any name such as `def total(initial=5, *, extra_number)`.

## The return Statement 

The `return` statement is used to *return* from a function i.e. break out of the function. We can optionally *return a value* from the function as well.

Example (save as `func_return.py`):

~~~python
def maximum(x, y):
    if x > y:
        return x
    elif x == y:
        return 'The numbers are equal'
    else:
        return y

print(maximum(2, 3))
~~~

Output:

~~~
$ python3 func_return.py
3
~~~

How It Works:

The `maximum` function returns the maximum of the parameters, in this case the numbers supplied to the function. It uses a simple `if..else` statement to find the greater value and then *returns* that value.

Note that a `return` statement without a value is equivalent to `return None`. `None` is a special type in Python that represents nothingness. For example, it is used to indicate that a variable has no value if it has a value of `None`.

Every function implicitly contains a `return None` statement at the end unless you have written your own `return` statement. You can see this by running `print(someFunction())` where the function `someFunction` does not use the `return` statement such as:

~~~python
def someFunction():
    pass
~~~

The `pass` statement is used in Python to indicate an empty block of statements.

Note

:   There is a built-in function called `max` that already implements the 'find maximum' functionality, so use this built-in function whenever possible.

## DocStrings 

Python has a nifty feature called *documentation strings*, usually referred to by its shorter name *docstrings*. DocStrings are an important tool that you should make use of since it helps to document the program better and makes it easier to understand. Amazingly, we can even get the docstring back from, say a function, when the program is actually running!

Example (save as `func_doc.py`):

~~~python
def printMax(x, y):
    '''Prints the maximum of two numbers.

    The two values must be integers.'''
    x = int(x) # convert to integers, if possible
    y = int(y)

    if x > y:
        print(x, 'is maximum')
    else:
        print(y, 'is maximum')

printMax(3, 5)
print(printMax.__doc__)
~~~

Output:

~~~
$ python3 func_doc.py
5 is maximum
Prints the maximum of two numbers.

        The two values must be integers.
~~~

How It Works:

A string on the first logical line of a function is the *docstring* for that function. Note that DocStrings also apply to [Modules](#modules) and [classes](#object-oriented-programming) which we will learn about in the respective chapters.

The convention followed for a docstring is a multi-line string where the first line starts with a capital letter and ends with a dot. Then the second line is blank followed by any detailed explanation starting from the third line. You are *strongly advised* to follow this convention for all your docstrings for all your non-trivial functions.

We can access the docstring of the `printMax` function using the `__doc__` (notice the *double underscores*) attribute (name belonging to) of the function. Just remember that Python treats *everything* as an object and this includes functions. We'll learn more about objects in the chapter on [classes](#object-oriented-programming).

If you have used `help()` in Python, then you have already seen the usage of docstrings! What it does is just fetch the `__doc__` attribute of that function and displays it in a neat manner for you. You can try it out on the function above - just include `help(printMax)` in your program. Remember to press the `q` key to exit `help`.

Automated tools can retrieve the documentation from your program in this manner. Therefore, I *strongly recommend* that you use docstrings for any non-trivial function that you write. The `pydoc` command that comes with your Python distribution works similarly to `help()` using docstrings.

## Summary 

We have seen so many aspects of functions but note that we still haven't covered all aspects of them. However, we have already covered most of what you'll use regarding Python functions on an everyday basis.

Next, we will see how to use as well as create Python modules.
