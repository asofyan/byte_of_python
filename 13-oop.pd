# Pemrograman Berbasis Obyek 

Seluruh program yang kita tulis sejauh ini, dibuat atas dasar fungsi, yakni satu kelompok blok dari stetemen yang bertugas untuk memproses data. Pendekatan ini dinamakan *procedure-oriented* atau *pemrograman berbasis prosedur*. Ada cara lain dalam mengatur perangkat lunak Anda yakni dengan menggabungkan data dan fungsi dan menyatukannya ke dalam sesuatu yang disebut sebagai obyek. Paradigma ini dinamakan pemrograman *berbasis obyek*. Dalam banyak hal, Anda bisa menggunakan pemrograman presedural, namun saat menulis program dalam skala program, atau punya masalah yang lebih cocok dengan pendekatan ini, Anda dapat menggunakan teknik pemrograman berbasis obyek. 

Kelas dan obyek adalah dua aspek utama dalam pemerograman berbasis obyek. Sebuah **kelas (class)** membuat *tipe (type)* baru dimana **obyek (object)** merupakan *perwujudan (instance)* dari sebuah kelas. Bisa dianalogikan Anda punya variabel dengan tipe `int`, dapat diterjemahkan bahwa variabel yang menyimpan integer tersebut merupakan variabel perwujudan dari kelas `int`.

Catatan untuk Programmer Bahasa Statik

:   Perlu dicatat bahwa integer juga diperlakukan sebagai obyek (dari kelas `int`). Hal ini berbeda di C++ dan Java (sebelum versi 1.5) di mana integer merupakan tipe bawaan awal (primitive native types). Lihat `help(int)` untuk informasi detil dari kelas ini.

Programmer C# dan Java 1.5 akan mengenali hal ini mirip dengan konsep *boxing dan unboxing*.

Obyek dapat menyimpan data dengan menggunakan variabel umum yang *dimiliki* oleh obyek tersebut. Variabel yang ikut dalam sebuah obyek atau kelas sering disebut sebagai **fields**. Obyek juga dapat digunakan dengan memanfaatkan fungsi yang *dimiliki* oleh sebuah kelas. Fungsi ini disebut sebagai **metode/methods** dari sebuah kelas. Terminologi ini penting sebab hal ini membantu kita untuk membedakan antara fungsi dan variabel yang independen dengan fungsi dan variabel yang merupakan milik dari kelas atau obyek. Secara bersama-sama, fields dan methods dapat disebut sebagai **atribut** dari sebuah kelas.

Fields ada dua jenis - mereka ikut dalam sebuah wujud/obyek dari sebuah kelas, atau mereka merupakan bagian dari kelas itu sendiri. Ini sering disebut sebagi **variabel terwujud/instance variables** dan **variabel kelas/class variables**.

Sebuah kelas dibuat dengan kata kunci `class`. Fields dan methods dari sebuah kelas, akan dimasukkan dalam blo yang menjorok (_indented block_).

## Diri/Self 

Metode kelas punya perbedaan khusus terhadap fungsi yang biasa Anda kenal - mereka harus punya nama depan tambahan yang harus ditambahkan di seluruh awal daftar parameter, namun Anda **tidak perlu** memberi nilai terhadap parameter ini saat Anda memanggil metode-nya, Python akan secara otomatis memberikannya. Variabel yang khusus ini akan merujuk pada obyek itu *sendiri*, dan secara umum telah disepakati, dengan nama `diri` atau `self`.

Meskipun, Anda dapat memberikan nama apa saja terhadap parameter ini, namun *sangat disarankan* Anda menggunakan nama `self` - dan nama selain itu pastinya akan memancing pertanyaan. Ada keuntungan menggunakan nama yang baku - setiap pembaca program Anda akan segera mengenalinua, dan bahkan IDE (Integrated Development Environments - Alat Bantu Pengembangan yang Terintegrasi) dapat membantu jika Anda menggunakan `self`.

Catatan untuk C++/Java/C# Programmers

:    `self` di Python sebanding dengan pointer `this` di C++ dan `this` di Java dan C#

Anda mungkin heran, kenapa Python memberikan nilai langsung untuk `self` dan kenapa Anda tidak perlu memberikan nilai terhadapnya. Berikut sebuah contoh yang dapat mempermudah Anda memahaminya. Misalnya Anda punya kelas dengan nama `KelasKu` dan perwujudan (instance) dari kelas ini dinamakan `obyekku`. Ketika Anda memanggil metode dari obyek ini dengan nama `obyekku.metode(argumen1, argumen2)`, secara otomatis akan dikonversikan oleh Python menjadi `KelasKu.metode(obyekku, argumen1, argumen2(` - inilah yang khusus terhadap `self`. 

Ini juga berarti jika Anda punya metode yang tidak memiliki argumen, Anda tetap harus memberikan satu arguman - `self`. 

## Kelas 

Kelas yang sederhana dapat dilihat dalam contoh di bawah ini (simpan sebagai `kelassederhana.py`).

~~~python
class Person:
    pass # blok kosong 

p = Person()
print(p)
~~~

Keluaran:

~~~
$ python3 kelassederhana.py
<__main__.Person object at 0x019F85F0>
~~~

Bagaimana Cara Kerjanya:

Kita membuat kelas baru dengan statemen `class` yang diikuti nama kelasnya. Kemudian di bawahnya ditambahkan statemen dalam blok yang menjorok ke dalam, sebagai isi baris perintah dari kelas tersebut. Kita menambahkan blok kosong dengan statemen `pass`. 

Kemudian, kita membuat obyek/wujud dari kelas ini dengan nama kelas yang diikuti oleh kurung kurawal. (Kita akan belajar [lebih banyak tentang perwujudan/_instantiation_](#metode-init)  di bagian berikutnya). Sebagai verifikasi, kita konfirmasi jenis variabel tersebut sebagai sebuah obyek dengan menampilkannya di layar. Informasi tersebut menunjukkan bahwa kita mempunya sebuah wujud kelas `Person` di dalam modul `__main__`.

Perhatikan bahwa alamat di mana obyek Anda berada di dalam memori komputer juga dicetak. Alamat ini akan memiliki nilai yang berbeda antara apa yang muncul di layar komputer Anda dengan yang tampilan di atas, mengingat Python akan menyimpan obyek di mana saja dia temukan ruangan kosong. 

## Metode Obyek 

Kita telah diskusikan bahwa kelas/obyek dapat memiliki metode yang tugasnya mirip dengan fungsi (pada pemrograman prosedural), kecuali ada tambahan variabel bernama `self`. Kita akan lihat dalam contoh berikut (simpan dengan nama `metode.py`).

~~~python
class Person:
    def sapaHalo(self):
        print('Halo, apa kabar?')

p = Person()
p.sapaHalo()

# Contoh di atas dapat diperpendek dengan menuliskan Person().sapaHalo()
~~~

Keluaran:

~~~
$ python3 metode.py
Halo, apa kabar?
~~~

Bagaimana Cara Kerjanya:

Di sini kita lihat bagaimana `self` bekerja. Perhatikan bahwa metode `sapaHalo` tidak membutuhkan satu parameterpun, namun dalam definisi di dalam kelasnya, masih tetap membutuhkan parameter `self`.

## Metode __init__ 

Ada banyak nama metode yang memiliki kegunaan khusus dalam kelas di Python. Kita akan lihat pentingnya metode `__init__` sebagai berikut.

Metode `__init__` otomatis berjalan jika sebuah obyek diwujudkan dari kelas. Metode ini berguna untuk *inisialisasi* hal-hal yang perlu Anda persiapkan saat obyek Anda mewujud. Perhatikan bahwa di depan init ada dua garis bawah di belakang dan di depan.

Contoh (simpan sebagai `class_init.py`):

~~~python
class Person:
    def __init__(self, nama):
        self.nama = nama
    def sapaHalo(self):
        print('Halo, nama saya', self.nama)

p = Person('Swaroop')
p.sapaHalo()

# Contoh sederhana ini juga bisa ditulis seperti ini: Person('Swaroop').sapaHalo()
~~~

Keluaran:

~~~
$ python3 class_init.py
Halo, nama saya Swaroop
~~~

Bagaimana Cara Kerjanya:

Di sini kita definisikan metode `__init__` dengan mengambil `nama` sebagai parameter ( dan sebagaimana biasa, bersamaan dengan `self`). Di sini kita baru saja membuat field baru dengan nama `nama`. Perhatikan bahwa keduanya merupakan variabel yang berbeda meskipun keduanya sama-sama dipanggil dengan variabel `nama`. Hal ini bukan menjadi masalah mengingat notasi titik `self.nama` berarti merujuk pada sesuatu yang dipanggil "nama" dan merupakan bagian dari obyek yang dipanggil dengan "self" dan variable `nama` lainnya merupakan variabel lokal. Mengingat kita secara eksplisit mereferensikan nama yang mana, sehingga hal ini tidak membingungkan lagi.

YAng paling penting adalah, perhatikan bahwa kita tidak secara eksplisit memanggil metode `__init__ namun kita melemparkan arguman dalam kuruung, yang diikuti nama kelas, jika ingin membuat kelas ini mewujud dalam obyek. Metode ini sangat spesifik di Python.

Sekarang, kita dapat menggunakan `self.nama` untuk diberikan dalam metode/fungsi, yang dalam contoh di atas bernama `sapaHalo`.

## Kelas dan Variabel Obyek

Kita telah diskusikan sebelumnya beberapa fungsi bagian dari kelas dan obyek (yakni metode), sekarang kita belajar bagian yang lain, yakni data. Data di dalam obyek, atau disebut field, sebenarnya merupakan variabel biasa nameun *terikat* **lingkup nama** atau **name spaces** dari sebuah kelas atau obyek. Ini rtinya bahwa nama hanya valid di dalam konteks obyek atau kelas yang bersangkutan saja. Karena itulah mereka sering disebut sebagai *lingkup nama* atau *name spaces*.

Ada dua jenis *fields* - variabel kelas atau variabel obyek yang dikelompokkan atas dasar apakah kelas atau obyek tersebut *memiliki* variabel tersebut. 

*Variabel kelas* merupakan entitas yang dimanfaatkan bersama-sama - dia dapat diakses oleh seluruh perwujudan (_instance_) kelas yang bersangkutan. Jadi jika Anda mendefinisikan satu variabel - dia merujuk pada satu variabel yang bersangkutan, dan jika ada perubahan dilakukan oleh salah satu obyek, maka perubahan tersebut akan dilihat oleh seluruh wujud obyek (instances).

*Variabel Obyek* dimiliki oleh secara tersendiri oleh obyek dari kelas yang bersangkutan. Dalam hal ini, setiap obyek hanya memiliki satu salinan field yang bersangkutan. Dengan kata lain field tersebut tidak akan dibagikan dan tidak berhubungan dengan field lain di obyek berbeda meskipun namanya sama. Untuk mempermudah pemahaman, berikut contohnya (simpan sebagai `varobyek.py`):
	
~~~python
class Robot:
    '''Mewakili sebuah robot dengan nama.'''

    # Sebuah variabl, untuk menampung hitungan jumlah robot
    populasi = 0
 
    def __init__(self, nama):
        '''Inisialisasi data.'''
        self.nama = nama
        print('(Inisialisasi {0})'.format(self.nama))
 
        # Saat robot ini dibuat, jumlah robot ditambahkan
        # ke dalam populasi
        Robot.populasi += 1
 
    def __del__(self):
        '''Saya mati.'''
        print('{0} sedang dimusnahkan!'.format(self.nama))
 
        Robot.populasi -= 1
 
        if Robot.populasi == 0:
            print('{0} adalah robot terakhir.'.format(self.nama))
        else:
            print('Masih ada {0:d} robot yang sedang bekerja.'.format(Robot.populasi))
 
    def sapaHalo(self):
        '''Ucapan salam dari salah seorang robot.
 
        Yah, tentu saja mereka dapat melakukannya.'''
        print('Salam, tuan saya memberi nama saya {0}.'.format(self.nama))

    def adaBerapa():
        '''Menampilkan jumlah populasi saat ini.'''
        print('Kita memiliki {0:d} robot.'.format(Robot.populasi))
    adaBerapa = staticmethod(adaBerapa)
 
droid1 = Robot('R2-D2')
droid1.sapaHalo()
Robot.adaBerapa()
 
droid2 = Robot('C-3PO')
droid2.sapaHalo()
Robot.adaBerapa()
 
print("\nPara robot dapat menjalankan beberapa tugas di sini.\n")

print("Pada robot sudah selesai menjaalankan tugas. Mari kita musnahkan mereka.")
del droid1
del droid2

Robot.adaBerapa()
~~~

Keluaran:

~~~
$ python3 varobyek.py
(Inisialisasi R2-D2)
Salam, tuan saya memberi nama saya R2-D2.
Kita memiliki 1 robot.
(Inisialisasi C-3PO)
Salam, tuan saya memberi nama saya C-3PO.
Kita memiliki 2 robot.

Para robot dapat menjalankan beberapa tugas di sini.

Para robot sudah selesai menjalankan tugas. Mari kita musnahkan mereka.
R2-D2 sedang dimusnahkan! 
Masih ada 1 robot yang sedang bekerja.
C-3PO sedang dimusnahkan!
C-3PO adalah robot terakhir.
Kita memiliki 0 robot.
~~~

Bagaimana Cara Kerjanya:

Skrip di atas merupakan contoh yang panjang, namun membantu mendemonstrasikan bagaimana sebuah variabel obyek dan kelas bekerja. Di sini, `populasi` merupakan milik kelas `Robot` sehingga ini bisa kita sebut sebagai variabel kelas. Lalu variabel `nama` merupakan milik obyek (sehingga dalam penggunaannya memakai awalan `self`), dan ini disebut sebagai variabel obyek. 

Sehingga, kita bisa menyebut variabel kelas `populasi` dengan sebutan `Robot.populasi`, dan bukan `self.populasi`. Kita merujuk pada variabel obyek `nama` dengan penulisan `self.nama` sebagai metode di dalam obyek. Mohon selalu diingat perbedaan sederhana antara variabel kelas dan variabel obyek. Dan catat pula bahwa nama variabel obyek yang memiliki nama yang sama dengan variabel kelas, akan menyembunyikan variabel kelas!

`adaBerapa` sebetulnya merupakan metode yang mengikuti kelas dan bukan obyek. Ini berarti bahwa kita bisa mendefinisikannya sebagai `classmethod` atau sebagai `staticmethod` tergantung apakah kita ingin mengetahui di kelas apa kita saat ini. Mengingat kita tidak perlu mengetahui informasi tersebut, kita akan menggunakan `staticmethod`. 

Kita dapat memperoleh hal yang sama dengan menggunakan [dekorator](http://www.ibm.com/developerworks/linux/library/l-cpdecor.html):

~~~python
@staticmethod
def adaBerapa():
    '''Menampilkan jumlah populasi saat ini.'''
    print('Kita memiliki {0:d} robot.'.format(Robot.populasi))
~~~

Dekorator dapat dibayangkan sebagai jalan pintas untuk memanggil statemen secara eksplisit, sebagaimana yang kita lihat dalam contoh.

Perhatikan bahwa metode `__init__` yang digunakan untuk inisialisasi wujud `Robot` dengan nama. Dalam metode ini, kita meningkatkan jumlah `populasi` dengan tambahan 1 setelah robot ditambahkan. Juga perhatikan bahwa nilai `self.nama` khusus di tiap obyek yang mengindikasikan cara kerja variabel obyek. 

Ingat, bahwa Anda harus merujuk pada variabel dan metode di dalam obyek yang sama dengan **hanya** menggunakan awalan `self`. Ini dinamakan sebagai *referensi atribut/attribute reference*.

Dalam program ini, kita juga melihat penggunaan **docstrings** untuk kelas maupun metode. Kita dapat mengakses kelas docstring ini pada saat program dijalankan dengan menggunakan `Robot.__doc__` dan docstring untuk metodenya dengan memanggil `Robot.sapaHalo.__doc__`.

Seperti metode `__init__`, ada metode khusus lainnya yang disebut dengan metode `__del__` dan dipanggil saat obyek akan dimusnahkan atau tidak akan digunakan lagi oleh komputer, sehingga kita bisa menggunakan kembali bagian dari memori komputer tersebut. Dalam metode ini kita cukup kurangi 1 nilai dari `Robot.populasi`.

Metode `__del__` dijalankan ketika obyek tidak lagi digunakan dan tidak ada garansi lagi *kapan* metode tersebut akan dijalankan. Jika Anda ingin melihatnya secara eksplisit, gunakan statemen `del` secara langsung, di mana sudah kita lakukan dalam contoh sebelumnya.

Semua anggota kelas bersifat publik. Ada satu pengecualian: Jika Anda menggunakan data dengan *nama berawalan dua garis bawah* seperti `__varprivat`, Python menggunakan penyamaran-nama secara efektif yang membuat variabel tersebut menjadi privat. 

Sehingga, sudah ada ketentuan tidak tertulis yang diikuti bahwa setiap variabel yang hanya boleh digunakan dalam kelas atau obyek harus diawali dengan garis bawah, selain itu dianggap sebagai publik dan dapat dimanfaatkan oleh kelas/obyek yang lain. Ingat bahwa ini hanya konvensi dan tidak dipaksakan oleh Python (kecuali untuk awalan dua garis bawah).

Catatan untuk Programmer C++/Java/C# 

:   Semua anggota kelas (termasuk anggota data) bersifat *publik* dan seluruh metode di Python bersifat *virtual*.

## Inheritance 

One of the major benefits of object oriented programming is **reuse** of code and one of the ways this is achieved is through the *inheritance* mechanism. Inheritance can be best imagined as implementing a *type and subtype* relationship between classes.

Suppose you want to write a program which has to keep track of the teachers and students in a college. They have some common characteristics such as name, age and address. They also have specific characteristics such as salary, courses and leaves for teachers and, marks and fees for students.

You can create two independent classes for each type and process them but adding a new common characteristic would mean adding to both of these independent classes. This quickly becomes unwieldy.

A better way would be to create a common class called `SchoolMember` and then have the teacher and student classes *inherit* from this class i.e. they will become sub-types of this type (class) and then we can add specific characteristics to these sub-types.

There are many advantages to this approach. If we add/change any functionality in `SchoolMember`, this is automatically reflected in the subtypes as well. For example, you can add a new ID card field for both teachers and students by simply adding it to the SchoolMember class. However, changes in the subtypes do not affect other subtypes. Another advantage is that if you can refer to a teacher or student object as a `SchoolMember` object which could be useful in some situations such as counting of the number of school members. This is called **polymorphism** where a sub-type can be substituted in any situation where a parent type is expected i.e. the object can be treated as an instance of the parent class.

Also observe that we *reuse* the code of the parent class and we do not need to repeat it in the different classes as we would have had to in case we had used independent classes.

The `SchoolMember` class in this situation is known as the *base class* or the *superclass*. The `Teacher` and `Student` classes are called the *derived classes* or *subclasses*.

We will now see this example as a program (save as `inherit.py`):

~~~python
class SchoolMember:
    '''Represents any school member.'''
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print('(Initialized SchoolMember: {0})'.format(self.name))
    
    def tell(self):
        '''Tell my details.'''
        print('Name:"{0}" Age:"{1}"'.format(self.name, self.age), end=" ")

class Teacher(SchoolMember):
    '''Represents a teacher.'''
    def __init__(self, name, age, salary):
        SchoolMember.__init__(self, name, age)
        self.salary = salary
        print('(Initialized Teacher: {0})'.format(self.name))

    def tell(self):
        SchoolMember.tell(self)
        print('Salary: "{0:d}"'.format(self.salary))

class Student(SchoolMember):
    '''Represents a student.'''
    def __init__(self, name, age, marks):
        SchoolMember.__init__(self, name, age)
        self.marks = marks
        print('(Initialized Student: {0})'.format(self.name))
    
    def tell(self):
        SchoolMember.tell(self)
        print('Marks: "{0:d}"'.format(self.marks))

t = Teacher('Mrs. Shrividya', 40, 30000)
s = Student('Swaroop', 25, 75)

print() # prints a blank line

members = [t, s]
for member in members:
    member.tell() # works for both Teachers and Students
~~~

Output:

~~~
$ python3 inherit.py
(Initialized SchoolMember: Mrs. Shrividya)
(Initialized Teacher: Mrs. Shrividya)
(Initialized SchoolMember: Swaroop)
(Initialized Student: Swaroop)

Name:"Mrs. Shrividya" Age:"40" Salary: "30000"
Name:"Swaroop" Age:"25" Marks: "75"
~~~

How It Works:

To use inheritance, we specify the base class names in a tuple following the class name in the class definition. Next, we observe that the `__init__` method of the base class is explicitly called using the `self` variable so that we can initialize the base class part of the object. This is very important to remember - Python does not automatically call the constructor of the base class, you have to explicitly call it yourself.

We also observe that we can call methods of the base class by prefixing the class name to the method call and then pass in the `self` variable along with any arguments.

Notice that we can treat instances of `Teacher` or `Student` as just instances of the `SchoolMember` when we use the `tell` method of the `SchoolMember` class.

Also, observe that the `tell` method of the subtype is called and not the `tell` method of the `SchoolMember` class. One way to understand this is that Python *always* starts looking for methods in the actual type, which in this case it does. If it could not find the method, it starts looking at the methods belonging to its base classes one by one in the order they are specified in the tuple in the class definition.

A note on terminology - if more than one class is listed in the inheritance tuple, then it is called *multiple inheritance*.

The `end` parameter is used in the `tell()` method to change a new line to be started at the end of the `print()` call to printing spaces.

## Summary 

We have now explored the various aspects of classes and objects as well as the various terminologies associated with it. We have also seen the benefits and pitfalls of object-oriented programming. Python is highly object-oriented and understanding these concepts carefully will help you a lot in the long run.

Next, we will learn how to deal with input/output and how to access files in Python.
