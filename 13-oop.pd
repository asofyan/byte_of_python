# Pemrograman Berbasis Obyek 

Seluruh program yang kita tulis sejauh ini, dibuat atas dasar fungsi, yakni satu kelompok blok dari stetemen yang bertugas untuk memproses data. Pendekatan ini dinamakan *procedure-oriented* atau *pemrograman berbasis prosedur*. Ada cara lain dalam mengatur perangkat lunak Anda yakni dengan menggabungkan data dan fungsi dan menyatukannya ke dalam sesuatu yang disebut sebagai obyek. Paradigma ini dinamakan pemrograman *berbasis obyek*. Dalam banyak hal, Anda bisa menggunakan pemrograman presedural, namun saat menulis program dalam skala program, atau punya masalah yang lebih cocok dengan pendekatan ini, Anda dapat menggunakan teknik pemrograman berbasis obyek. 

Kelas dan obyek adalah dua aspek utama dalam pemerograman berbasis obyek. Sebuah **kelas (class)** membuat *tipe (type)* baru dimana **obyek (object)** merupakan *perwujudan (instance)* dari sebuah kelas. Bisa dianalogikan Anda punya variabel dengan tipe `int`, dapat diterjemahkan bahwa variabel yang menyimpan integer tersebut merupakan variabel perwujudan dari kelas `int`.

Catatan untuk Programmer Bahasa Statik

:   Perlu dicatat bahwa integer juga diperlakukan sebagai obyek (dari kelas `int`). Hal ini berbeda di C++ dan Java (sebelum versi 1.5) di mana integer merupakan tipe bawaan awal (primitive native types). Lihat `help(int)` untuk informasi detil dari kelas ini.

Programmer C# dan Java 1.5 akan mengenali hal ini mirip dengan konsep *boxing dan unboxing*.

Obyek dapat menyimpan data dengan menggunakan variabel umum yang *dimiliki* oleh obyek tersebut. Variabel yang ikut dalam sebuah obyek atau kelas sering disebut sebagai **fields**. Obyek juga dapat digunakan dengan memanfaatkan fungsi yang *dimiliki* oleh sebuah kelas. Fungsi ini disebut sebagai **metode/methods** dari sebuah kelas. Terminologi ini penting sebab hal ini membantu kita untuk membedakan antara fungsi dan variabel yang independen dengan fungsi dan variabel yang merupakan milik dari kelas atau obyek. Secara bersama-sama, fields dan methods dapat disebut sebagai **atribut** dari sebuah kelas.

Fields ada dua jenis - mereka ikut dalam sebuah wujud/obyek dari sebuah kelas, atau mereka merupakan bagian dari kelas itu sendiri. Ini sering disebut sebagi **variabel terwujud/instance variables** dan **variabel kelas/class variables**.

Sebuah kelas dibuat dengan kata kunci `class`. Fields dan methods dari sebuah kelas, akan dimasukkan dalam blo yang menjorok (_indented block_).

## Diri/Self 

Metode kelas punya perbedaan khusus terhadap fungsi yang biasa Anda kenal - mereka harus punya nama depan tambahan yang harus ditambahkan di seluruh awal daftar parameter, namun Anda **tidak perlu** memberi nilai terhadap parameter ini saat Anda memanggil metode-nya, Python akan secara otomatis memberikannya. Variabel yang khusus ini akan merujuk pada obyek itu *sendiri*, dan secara umum telah disepakati, dengan nama `diri` atau `self`.

Meskipun, Anda dapat memberikan nama apa saja terhadap parameter ini, namun *sangat disarankan* Anda menggunakan nama `self` - dan nama selain itu pastinya akan memancing pertanyaan. Ada keuntungan menggunakan nama yang baku - setiap pembaca program Anda akan segera mengenalinua, dan bahkan IDE (Integrated Development Environments - Alat Bantu Pengembangan yang Terintegrasi) dapat membantu jika Anda menggunakan `self`.

Catatan untuk C++/Java/C# Programmers

:    `self` di Python sebanding dengan pointer `this` di C++ dan `this` di Java dan C#

Anda mungkin heran, kenapa Python memberikan nilai langsung untuk `self` dan kenapa Anda tidak perlu memberikan nilai terhadapnya. Berikut sebuah contoh yang dapat mempermudah Anda memahaminya. Misalnya Anda punya kelas dengan nama `KelasKu` dan perwujudan (instance) dari kelas ini dinamakan `obyekku`. Ketika Anda memanggil metode dari obyek ini dengan nama `obyekku.metode(argumen1, argumen2)`, secara otomatis akan dikonversikan oleh Python menjadi `KelasKu.metode(obyekku, argumen1, argumen2(` - inilah yang khusus terhadap `self`. 

Ini juga berarti jika Anda punya metode yang tidak memiliki argumen, Anda tetap harus memberikan satu arguman - `self`. 

## Kelas 

Kelas yang sederhana dapat dilihat dalam contoh di bawah ini (simpan sebagai `kelassederhana.py`).

~~~python
class Person:
    pass # blok kosong 

p = Person()
print(p)
~~~

Keluaran:

~~~
$ python3 kelassederhana.py
<__main__.Person object at 0x019F85F0>
~~~

Bagaimana Cara Kerjanya:

Kita membuat kelas baru dengan statemen `class` yang diikuti nama kelasnya. Kemudian di bawahnya ditambahkan statemen dalam blok yang menjorok ke dalam, sebagai isi baris perintah dari kelas tersebut. Kita menambahkan blok kosong dengan statemen `pass`. 

Kemudian, kita membuat obyek/wujud dari kelas ini dengan nama kelas yang diikuti oleh kurung kurawal. (Kita akan belajar [lebih banyak tentang perwujudan/_instantiation_](#metode-init)  di bagian berikutnya). Sebagai verifikasi, kita konfirmasi jenis variabel tersebut sebagai sebuah obyek dengan menampilkannya di layar. Informasi tersebut menunjukkan bahwa kita mempunya sebuah wujud kelas `Person` di dalam modul `__main__`.

Perhatikan bahwa alamat di mana obyek Anda berada di dalam memori komputer juga dicetak. Alamat ini akan memiliki nilai yang berbeda antara apa yang muncul di layar komputer Anda dengan yang tampilan di atas, mengingat Python akan menyimpan obyek di mana saja dia temukan ruangan kosong. 

## Metode Obyek 

Kita telah diskusikan bahwa kelas/obyek dapat memiliki metode yang tugasnya mirip dengan fungsi (pada pemrograman prosedural), kecuali ada tambahan variabel bernama `self`. Kita akan lihat dalam contoh berikut (simpan dengan nama `metode.py`).

~~~python
class Person:
    def sapaHalo(self):
        print('Halo, apa kabar?')

p = Person()
p.sapaHalo()

# Contoh di atas dapat diperpendek dengan menuliskan Person().sapaHalo()
~~~

Keluaran:

~~~
$ python3 metode.py
Halo, apa kabar?
~~~

Bagaimana Cara Kerjanya:

Di sini kita lihat bagaimana `self` bekerja. Perhatikan bahwa metode `sapaHalo` tidak membutuhkan satu parameterpun, namun dalam definisi di dalam kelasnya, masih tetap membutuhkan parameter `self`.

## Metode __init__ 

Ada banyak nama metode yang memiliki kegunaan khusus dalam kelas di Python. Kita akan lihat pentingnya metode `__init__` sebagai berikut.

Metode `__init__` otomatis berjalan jika sebuah obyek diwujudkan dari kelas. Metode ini berguna untuk *inisialisasi* hal-hal yang perlu Anda persiapkan saat obyek Anda mewujud. Perhatikan bahwa di depan init ada dua garis bawah di belakang dan di depan.

Contoh (simpan sebagai `class_init.py`):

~~~python
class Person:
    def __init__(self, nama):
        self.nama = nama
    def sapaHalo(self):
        print('Halo, nama saya', self.nama)

p = Person('Swaroop')
p.sapaHalo()

# Contoh sederhana ini juga bisa ditulis seperti ini: Person('Swaroop').sapaHalo()
~~~

Keluaran:

~~~
$ python3 class_init.py
Halo, nama saya Swaroop
~~~

Bagaimana Cara Kerjanya:

Di sini kita definisikan metode `__init__` dengan mengambil `nama` sebagai parameter ( dan sebagaimana biasa, bersamaan dengan `self`). Di sini kita baru saja membuat field baru dengan nama `nama`. Perhatikan bahwa keduanya merupakan variabel yang berbeda meskipun keduanya sama-sama dipanggil dengan variabel `nama`. Hal ini bukan menjadi masalah mengingat notasi titik `self.nama` berarti merujuk pada sesuatu yang dipanggil "nama" dan merupakan bagian dari obyek yang dipanggil dengan "self" dan variable `nama` lainnya merupakan variabel lokal. Mengingat kita secara eksplisit mereferensikan nama yang mana, sehingga hal ini tidak membingungkan lagi.

YAng paling penting adalah, perhatikan bahwa kita tidak secara eksplisit memanggil metode `__init__ namun kita melemparkan arguman dalam kuruung, yang diikuti nama kelas, jika ingin membuat kelas ini mewujud dalam obyek. Metode ini sangat spesifik di Python.

Sekarang, kita dapat menggunakan `self.nama` untuk diberikan dalam metode/fungsi, yang dalam contoh di atas bernama `sapaHalo`.

## Kelas dan Variabel Obyek

Kita telah diskusikan sebelumnya beberapa fungsi bagian dari kelas dan obyek (yakni metode), sekarang kita belajar bagian yang lain, yakni data. Data di dalam obyek, atau disebut field, sebenarnya merupakan variabel biasa nameun *terikat* **lingkup nama** atau **name spaces** dari sebuah kelas atau obyek. Ini rtinya bahwa nama hanya valid di dalam konteks obyek atau kelas yang bersangkutan saja. Karena itulah mereka sering disebut sebagai *lingkup nama* atau *name spaces*.

Ada dua jenis *fields* - variabel kelas atau variabel obyek yang dikelompokkan atas dasar apakah kelas atau obyek tersebut *memiliki* variabel tersebut. 

*Variabel kelas* merupakan entitas yang dimanfaatkan bersama-sama - dia dapat diakses oleh seluruh perwujudan (_instance_) kelas yang bersangkutan. Jadi jika Anda mendefinisikan satu variabel - dia merujuk pada satu variabel yang bersangkutan, dan jika ada perubahan dilakukan oleh salah satu obyek, maka perubahan tersebut akan dilihat oleh seluruh wujud obyek (instances).

*Variabel Obyek* dimiliki oleh secara tersendiri oleh obyek dari kelas yang bersangkutan. Dalam hal ini, setiap obyek hanya memiliki satu salinan field yang bersangkutan. Dengan kata lain field tersebut tidak akan dibagikan dan tidak berhubungan dengan field lain di obyek berbeda meskipun namanya sama. Untuk mempermudah pemahaman, berikut contohnya (simpan sebagai `varobyek.py`):
	
~~~python
class Robot:
    '''Mewakili sebuah robot dengan nama.'''

    # A class variable, counting the number of robots
    population = 0
 
    def __init__(self, name):
        '''Initializes the data.'''
        self.name = name
        print('(Initializing {0})'.format(self.name))
 
        # When this person is created, the robot
        # adds to the population
        Robot.population += 1
 
    def __del__(self):
        '''I am dying.'''
        print('{0} is being destroyed!'.format(self.name))
 
        Robot.population -= 1
 
        if Robot.population == 0:
            print('{0} was the last one.'.format(self.name))
        else:
            print('There are still {0:d} robots working.'.format(Robot.population))
 
    def sayHi(self):
        '''Greeting by the robot.
 
        Yeah, they can do that.'''
        print('Greetings, my masters call me {0}.'.format(self.name))

    def howMany():
        '''Prints the current population.'''
        print('We have {0:d} robots.'.format(Robot.population))
    howMany = staticmethod(howMany)
 
droid1 = Robot('R2-D2')
droid1.sayHi()
Robot.howMany()
 
droid2 = Robot('C-3PO')
droid2.sayHi()
Robot.howMany()
 
print("\nRobots can do some work here.\n")

print("Robots have finished their work. So let's destroy them.")
del droid1
del droid2

Robot.howMany()
~~~

Output:

~~~
$ python3 objvar.py
(Initializing R2-D2)
Greetings, my masters call me R2-D2.
We have 1 robots.
(Initializing C-3PO)
Greetings, my masters call me C-3PO.
We have 2 robots.

Robots can do some work here.

Robots have finished their work. So let's destroy them.
R2-D2 is being destroyed!
There are still 1 robots working.
C-3PO is being destroyed!
C-3PO was the last one.
We have 0 robots.
~~~

How It Works:

This is a long example but helps demonstrate the nature of class and object variables. Here, `population` belongs to the`Robot` class and hence is a class variable. The `name` variable belongs to the object (it is assigned using `self`) and hence is an object variable.

Thus, we refer to the `population` class variable as `Robot.population` and not as `self.population`. We refer to the object variable `name` using `self.name` notation in the methods of that object. Remember this simple difference between class and object variables. Also note that an object variable with the same name as a class variable will hide the class variable! 

The `howMany` is actually a method that belongs to the class and not to the object. This means we can define it as either a `classmethod` or a `staticmethod` depending on whether we need to know which class we are part of. Since we don't need such information, we will go for `staticmethod`	.

We could have also achieved the same using [decorators](http://www.ibm.com/developerworks/linux/library/l-cpdecor.html):

~~~python
@staticmethod
def howMany():
    '''Prints the current population.'''
    print('We have {0:d} robots.'.format(Robot.population))
~~~

Decorators can be imagined to be a shortcut to calling an explicit statement, as we have seen in this example.

Observe that the `__init__` method is used to initialize the `Robot` instance with a name. In this method, we increase the `population` count by 1 since we have one more robot being added. Also observe that the values of `self.name` is specific to each object which indicates the nature of object variables.

Remember, that you must refer to the variables and methods of the same object using the `self` **only**. This is called an *attribute reference*.

In this program, we also see the use of **docstrings** for classes as well as methods. We can access the class docstring at runtime using `Robot.__doc__` and the method docstring as `Robot.sayHi.__doc__`

Just like the `__init__` method, there is another special method `__del__` which is called when an object is going to die i.e. it is no longer being used and is being returned to the computer system for reusing that piece of memory. In this method, we simply decrease the `Robot.population` count by 1.

The `__del__` method is run when the object is no longer in use and there is no guarantee *when* that method will be run. If you want to explicitly see it in action, we have to use the `del` statement which is what we have done here.

All class members are public. One exception: If you use data members with names using the *double underscore prefix* such as `__privatevar`, Python uses name-mangling to effectively make it a private variable.

Thus, the convention followed is that any variable that is to be used only within the class or object should begin with an underscore and all other names are public and can be used by other classes/objects. Remember that this is only a convention and is not enforced by Python (except for the double underscore prefix).

Note for C++/Java/C# Programmers

:   All class members (including the data members) are *public* and all the methods are *virtual* in Python.

## Inheritance 

One of the major benefits of object oriented programming is **reuse** of code and one of the ways this is achieved is through the *inheritance* mechanism. Inheritance can be best imagined as implementing a *type and subtype* relationship between classes.

Suppose you want to write a program which has to keep track of the teachers and students in a college. They have some common characteristics such as name, age and address. They also have specific characteristics such as salary, courses and leaves for teachers and, marks and fees for students.

You can create two independent classes for each type and process them but adding a new common characteristic would mean adding to both of these independent classes. This quickly becomes unwieldy.

A better way would be to create a common class called `SchoolMember` and then have the teacher and student classes *inherit* from this class i.e. they will become sub-types of this type (class) and then we can add specific characteristics to these sub-types.

There are many advantages to this approach. If we add/change any functionality in `SchoolMember`, this is automatically reflected in the subtypes as well. For example, you can add a new ID card field for both teachers and students by simply adding it to the SchoolMember class. However, changes in the subtypes do not affect other subtypes. Another advantage is that if you can refer to a teacher or student object as a `SchoolMember` object which could be useful in some situations such as counting of the number of school members. This is called **polymorphism** where a sub-type can be substituted in any situation where a parent type is expected i.e. the object can be treated as an instance of the parent class.

Also observe that we *reuse* the code of the parent class and we do not need to repeat it in the different classes as we would have had to in case we had used independent classes.

The `SchoolMember` class in this situation is known as the *base class* or the *superclass*. The `Teacher` and `Student` classes are called the *derived classes* or *subclasses*.

We will now see this example as a program (save as `inherit.py`):

~~~python
class SchoolMember:
    '''Represents any school member.'''
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print('(Initialized SchoolMember: {0})'.format(self.name))
    
    def tell(self):
        '''Tell my details.'''
        print('Name:"{0}" Age:"{1}"'.format(self.name, self.age), end=" ")

class Teacher(SchoolMember):
    '''Represents a teacher.'''
    def __init__(self, name, age, salary):
        SchoolMember.__init__(self, name, age)
        self.salary = salary
        print('(Initialized Teacher: {0})'.format(self.name))

    def tell(self):
        SchoolMember.tell(self)
        print('Salary: "{0:d}"'.format(self.salary))

class Student(SchoolMember):
    '''Represents a student.'''
    def __init__(self, name, age, marks):
        SchoolMember.__init__(self, name, age)
        self.marks = marks
        print('(Initialized Student: {0})'.format(self.name))
    
    def tell(self):
        SchoolMember.tell(self)
        print('Marks: "{0:d}"'.format(self.marks))

t = Teacher('Mrs. Shrividya', 40, 30000)
s = Student('Swaroop', 25, 75)

print() # prints a blank line

members = [t, s]
for member in members:
    member.tell() # works for both Teachers and Students
~~~

Output:

~~~
$ python3 inherit.py
(Initialized SchoolMember: Mrs. Shrividya)
(Initialized Teacher: Mrs. Shrividya)
(Initialized SchoolMember: Swaroop)
(Initialized Student: Swaroop)

Name:"Mrs. Shrividya" Age:"40" Salary: "30000"
Name:"Swaroop" Age:"25" Marks: "75"
~~~

How It Works:

To use inheritance, we specify the base class names in a tuple following the class name in the class definition. Next, we observe that the `__init__` method of the base class is explicitly called using the `self` variable so that we can initialize the base class part of the object. This is very important to remember - Python does not automatically call the constructor of the base class, you have to explicitly call it yourself.

We also observe that we can call methods of the base class by prefixing the class name to the method call and then pass in the `self` variable along with any arguments.

Notice that we can treat instances of `Teacher` or `Student` as just instances of the `SchoolMember` when we use the `tell` method of the `SchoolMember` class.

Also, observe that the `tell` method of the subtype is called and not the `tell` method of the `SchoolMember` class. One way to understand this is that Python *always* starts looking for methods in the actual type, which in this case it does. If it could not find the method, it starts looking at the methods belonging to its base classes one by one in the order they are specified in the tuple in the class definition.

A note on terminology - if more than one class is listed in the inheritance tuple, then it is called *multiple inheritance*.

The `end` parameter is used in the `tell()` method to change a new line to be started at the end of the `print()` call to printing spaces.

## Summary 

We have now explored the various aspects of classes and objects as well as the various terminologies associated with it. We have also seen the benefits and pitfalls of object-oriented programming. Python is highly object-oriented and understanding these concepts carefully will help you a lot in the long run.

Next, we will learn how to deal with input/output and how to access files in Python.
