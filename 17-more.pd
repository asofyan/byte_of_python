# Lebih Lanjut 

Sejauh ini kita telah mempelajari hampir mayoritas seluruh aspek Python yang mungkin akan Anda gunakan. Dalam bab ini, kita akan bahas lagi beberapa aspek lanjutan yang akan membuat pengetahuan Anda terhadap Python semakin bulat. 

## Mengumpan tuples 

Pernahkah Anda menginginkan dua nilai kembalian yang berbeda dari satu fungsi? Anda dapat melakukannya di Python. Yang perlu dilakukan hanyalah menggunakan tuple.

~~~
>>> def ambil_detail_kesalahan():
...     return (2, 'detail kesalahan kedua')
...
>>> errnum, errstr = ambil_detail_kesalahan()
>>> errnum
2
>>> errstr
'detail kesalahan kedua'
~~~

Perhatikan bahwa penggunaan `a, b = <beberapa ekspresi>` menerjemahkan hasil dari ekspresi tersebut sebagai tuple dengan dua nilai. 

Jika Anda ingin menerjemahkan hasil sebagai `(a, <jenis macam-macam>)`, Anda cukup tambahkan bintang sebagaimana Anda menambahkannya dalam parameter fungsi:

~~~
>>> a, *b = [1, 2, 3, 4]
>>> a
1
>>> b
[2, 3, 4]
~~~

Cara ini juga yang paling cepat untuk memindah-gantikan nilai dari dua variabel di Python: 

~~~
>>> a = 5; b = 8
>>> a, b = b, a
>>> a, b
(8, 5)
~~~

## Metode Khusus 

Ada beberapa metode yang khusus Python seperti `__init__` dan `__del__` yang memiliki kepentingan khusus di dalam kelas.

Beberapa metode khusus digunakan untuk meniru perilaku tertentu dari tipe-tipe yang sudah ada secara baku (_built-in_). Misalnya, jika Anda ingin menggunakan metode indeks `x[key]` dalam kelas Anda (seperti saat Anda menggunakan list dan tuples), maka yang perlu Anda lakukan cukup mengimplementasi fungsi `__getitem__()` dan pekerjaan Anda selesai. Jika Anda memikirkannya, inilah yang dilakukan Python untuk kelas `list` itu sendiri!

Dalam tabel berikut akan Anda temukan beberapa metode khusus. Jika Anda ingin mengetahui seluruh metode khusus, [silakan lihat buku petunjuk](http://docs.python.org/py3k/reference/datamodel.html#specialnames).

`__init__(self, ...)`

:   Metode ini dipanggil sesaat sebelum obyek yang tercantum dibawahnya dibuat, dan metodenya siap digunakan.

`__del__(self)`

:   Dipanggil sebelum obyek dimusnahkan

`__str__(self)`

:   Dipanggil sebelum kita menggunakan fungsi `print` atau ketika `str()` digunakan

`__lt__(self, other)`

:   Dipanggil ketika operator *lebih kecil dari* (&lt;) digunakan. Mirip dengan hal ini, ada metode khusus lainnya untuk semua operator (+, &gt;, dll.)

`__getitem__(self, key)`

:   Dipanggil ketika operasi pembuatan indeks `x[key]` dilakukan.

`__len__(self)`

:   Dipanggil ketika fungsi baku `len()` digunakan untuk obyek yang bersifat urutan (sequence).

## Blok Statemen Tunggal

Kita telah pelajari sebelumnya bahwa setiap blok statemen dibuat terlepas dari level indentasinya. Meskipun demikian ada satu keberatan. Jika blok statemen hanya berisi satu statemen saja, maka Anda bisa teruskan ke dalam satu baris, misalnya, sebuah statemen besifat kondisional ataupun statemen perulangan. Contoh berikut memperjelas apa yang dimaksud sebelumnya:

~~~
>>> flag = True
>>> if flag: print('Ya')
Ya
~~~

Perhatikan bahwa statemen tunggal digunakan di satu tempat dan bukan di blok terpisah. Meskipun Anda dapat membuat program ini menjadi semakin *kecil* secara ukuran, namu saya sangat menganjurkan untuk menghindari metode jalan pintas ini, kecuali hanya untuk pengecekan kesalahan. Sebab utamanya adalah karena lebih mudah membuat statemen tambahan jika Anda menggunakan indentasi yang layak.

## Forms Lambda 

Statemen `lambda` digunakan untuk membuat obyek fungsi yang baru. Pada dasarnya, `lambda` mengambil parameter yang diikuti oleh ekspresi tunggal dan nilai dari eksresi ini akan dikembalikan oleh fungsi yang baru.

Contoh (simpan sebagai `lambda.py`):

~~~python
points = [ { 'x' : 2, 'y' : 3 }, { 'x' : 4, 'y' : 1 } ]
points.sort(key=lambda i : i['y'])
print(points)
~~~

Keluaran:

~~~
[{'x': 4, 'y': 1}, {'x': 2, 'y': 3}]
~~~

Bagaimana Cara Kerjanya:

Perhatikan bahwa metode `sort` dari sebuah `list` dapat mengambil parameter `key` yang menentukan bagaimana nanti list akan diurutkan (biasanya kita hanya tahu urut dari atas atau urut dari bawah). Dalam kasus ini, kita ingin menggunakan pengurutan sendiri, dan untuk itu kita membuat fungsi sendiri. Namun alih-alih kita membuat blok fungsi dengan `def` dan hanya digunakan satu kali di tempat ini, kita gunakan lambda untuk membuat fungsi baru. 

## Pengartian terhadap List (_List Comprehension_)

List comprehension digunakan untuk menurunkan sebuah _list_ baru dari _list_ yang sudah ada. Misal Anda punya daftar angka dan Anda ingin membuat sebuah list baru yang berisi angka dari list pertama dikalikan dua hanya jika angkanya lebih besar dari pada dua. _List comprehension_ ideal untuk situasi ini.

Contoh (simpan sebagai `list_comprehension.py`):

~~~python
list_satu = [2, 3, 4]
list_dua = [2*i for i in list_satu if i > 2]
print(list_dua)
~~~

Keluaran:

~~~
$ python3 list_comprehension.py
[6, 8]
~~~

Bagaimana Cara Kerjanya:

Here, we derive a new list by specifying the manipulation to be done (`2*i`) when some condition is satisfied (`if i > 2`). Note that the original list remains unmodified. 

The advantage of using list comprehensions is that it reduces the amount of boilerplate code required when we use loops to process each element of a list and store it in a new list.

## Receiving Tuples and Dictionaries in Functions 

There is a special way of receiving parameters to a function as a tuple or a dictionary using the * or ** prefix respectively. This is useful when taking variable number of arguments in the function.

~~~
>>> def powersum(power, *args):
...     '''Return the sum of each argument raised to        specified power.'''
...     total = 0
...     for i in args:
...         total += pow(i, power)
...     return total
...
>>> powersum(2, 3, 4)
25

>>> powersum(2, 10)
100
~~~

Because we have a `*` prefix on the `args` variable, all extra arguments passed to the function are stored in `args` as a tuple.  If a ** prefix had been used instead, the extra parameters would be considered to be key/value pairs of a dictionary.

## The assert statement 

The `assert` statement is used to assert that something is true. For example, if you are very sure that you will have at least one element in a list you are using and want to check this, and raise an error if it is not true, then `assert` statement is ideal in this situation. When the assert statement fails, an `AssertionError` is raised.

~~~
>>> mylist = ['item']
>>> assert len(mylist) >= 1
>>> mylist.pop()
'item'
>>> mylist
[]
>>> assert len(mylist) >= 1
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AssertionError
~~~

The `assert` statement should be used judiciously. Most of the time, it is better to catch exceptions, either handle the problem or display an error message to the user and then quit.

## Escape Sequences

Suppose, you want to have a string which contains a single quote (`'`), how will you specify this string? For example, the string is `What's your name?`. You cannot specify `'What's your name?'` because Python will be confused as to where the string starts and ends. So, you will have to specify that this single quote does not indicate the end of the string. This can be done with the help of what is called an *escape sequence*. You specify the single quote as `\'` - notice the backslash. Now, you can specify the string as `'What\'s your name?'`.

Another way of specifying this specific string would be `"What's your name?"` i.e. using double quotes. Similarly, you have to use an escape sequence for using a double quote itself in a double quoted string. Also, you have to indicate the backslash itself using the escape sequence `\\`.

What if you wanted to specify a two-line string? One way is to use a triple-quoted string as shown [previously](#triple-quotes) or you can use an escape sequence for the newline character - `\n` to indicate the start of a new line. An example is `This is the first line\nThis is the second line`. Another useful escape sequence to know is the tab - `\t`. There are many more escape sequences but I have mentioned only the most useful ones here.

One thing to note is that in a string, a single backslash at the end of the line indicates that the string is continued in the next line, but no newline is added. For example:

~~~python
"This is the first sentence. \
This is the second sentence."
~~~

is equivalent to 

~~~python
"This is the first sentence. This is the second sentence."
~~~

### Raw String

If you need to specify some strings where no special processing such as escape sequences are handled, then what you need is to specify a *raw* string by prefixing `r` or `R` to the string. An example is `r"Newlines are indicated by \n"`.

Note for Regular Expression Users

:   Always use raw strings when dealing with regular expressions. Otherwise, a lot of backwhacking may be required. For example, backreferences can be referred to as `'\\1'` or `r'\1'`.

## Summary 

We have covered some more features of Python in this chapter and yet we haven't covered all the features of Python. However, at this stage, we have covered most of what you are ever going to use in practice. This is sufficient for you to get started with whatever programs you are going to create.

Next, we will discuss how to explore Python further.
